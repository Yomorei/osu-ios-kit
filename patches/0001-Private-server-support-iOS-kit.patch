From f0d075dc2d40e7350b38e2f8cca3a6d5f12011a7 Mon Sep 17 00:00:00 2001
From: Yomorei <Yomoreibusiness@gmail.com>
Date: Tue, 3 Feb 2026 21:51:39 -0600
Subject: [PATCH] Private server support (iOS kit)

---
 osu.Game/Online/EndpointOverrideLoader.cs     | 195 +++++++++++++++
 .../Sections/Online/PrivateServersSettings.cs | 236 ++++++++++++++++++
 osu.Game/Overlays/Settings/SettingsSection.cs |  20 +-
 3 files changed, 444 insertions(+), 7 deletions(-)
 create mode 100644 osu.Game/Online/EndpointOverrideLoader.cs
 create mode 100644 osu.Game/Overlays/Settings/Sections/Online/PrivateServersSettings.cs

diff --git a/osu.Game/Online/EndpointOverrideLoader.cs b/osu.Game/Online/EndpointOverrideLoader.cs
new file mode 100644
index 0000000000..878fafe46d
--- /dev/null
+++ b/osu.Game/Online/EndpointOverrideLoader.cs
@@ -0,0 +1,195 @@
+using System;
+using System.IO;
+using System.Text.Json;
+using osu.Framework.Logging;
+using osu.Framework.Platform;
+
+namespace osu.Game.Online
+{
+    public static class EndpointOverrideLoader
+    {
+        private const string config_file = "endpoints.json";
+
+        private sealed class EndpointOverrideFile
+        {
+            public bool Enabled { get; set; } = true;
+
+            // well.. should be user friendly atleast ? | allow one root URL to drive everything.
+            public string? BaseUrl { get; set; }      // preferredddd
+            public string? DomainUrl { get; set; }    // aliasss
+            public string? ServerUrl { get; set; }    // alias??
+
+            // Optional OAuth
+            public string? APIClientSecret { get; set; }
+            public string? APIClientID { get; set; }
+
+            // Roots
+            public string? WebsiteUrl { get; set; }
+            public string? APIUrl { get; set; }
+
+            // Optional direct overrides (advanced)
+            public string? BeatmapSubmissionServiceUrl { get; set; }
+            public string? SpectatorUrl { get; set; }
+            public string? MultiplayerUrl { get; set; }
+            public string? MetadataUrl { get; set; }
+        }
+
+        public static bool TryApply(Storage storage, EndpointConfiguration endpoints, out string reason)
+        {
+            reason = string.Empty;
+
+            try
+            {
+                if (!storage.Exists(config_file))
+                {
+                    reason = $"{config_file} not found";
+                    return false;
+                }
+
+                string fullPath = storage.GetFullPath(config_file);
+
+                if (!File.Exists(fullPath))
+                {
+                    reason = $"{config_file} missing at resolved path";
+                    return false;
+                }
+
+                string json = File.ReadAllText(fullPath);
+
+                var options = new JsonSerializerOptions
+                {
+                    PropertyNameCaseInsensitive = true,
+                    ReadCommentHandling = JsonCommentHandling.Skip,
+                    AllowTrailingCommas = true
+                };
+
+                var cfg = JsonSerializer.Deserialize<EndpointOverrideFile>(json, options);
+
+                if (cfg == null)
+                {
+                    reason = $"{config_file} failed to parse";
+                    return false;
+                }
+
+                if (!cfg.Enabled)
+                {
+                    reason = $"{config_file} disabled";
+                    return false;
+                }
+
+                // If the user provided a single root URL, then it maps it to WebsiteUrl/APIUrl unless explicitly provided :_)
+                string? baseUrl = firstNonEmpty(cfg.BaseUrl, cfg.DomainUrl, cfg.ServerUrl);
+
+                bool baseProvided = !string.IsNullOrWhiteSpace(baseUrl);
+                bool websiteProvided = !string.IsNullOrWhiteSpace(cfg.WebsiteUrl);
+                bool apiProvided = !string.IsNullOrWhiteSpace(cfg.APIUrl);
+
+                if (baseProvided)
+                {
+                    if (!websiteProvided) cfg.WebsiteUrl = baseUrl;
+                    if (!apiProvided) cfg.APIUrl = baseUrl;
+
+                    websiteProvided = !string.IsNullOrWhiteSpace(cfg.WebsiteUrl);
+                    apiProvided = !string.IsNullOrWhiteSpace(cfg.APIUrl);
+                }
+
+                applyString(ref endpoints.APIClientSecret, cfg.APIClientSecret);
+                applyString(ref endpoints.APIClientID, cfg.APIClientID);
+
+                // Apply root URLs (must be absolute.. |  Website/API should not have "/" )
+                applyUrlNoTrailingSlash(ref endpoints.WebsiteUrl, cfg.WebsiteUrl, nameof(cfg.WebsiteUrl));
+                applyUrlNoTrailingSlash(ref endpoints.APIUrl, cfg.APIUrl, nameof(cfg.APIUrl));
+
+                // If the user touched the root (base/api/website), derive the common sub services
+                // unless they explicitly override those fields, but why would they {'_'}
+                bool shouldDeriveFromRoot = websiteProvided || apiProvided || baseProvided;
+
+                if (shouldDeriveFromRoot)
+                {
+                    if (string.IsNullOrWhiteSpace(cfg.SpectatorUrl))
+                        endpoints.SpectatorUrl = $"{endpoints.APIUrl}/signalr/spectator";
+
+                    if (string.IsNullOrWhiteSpace(cfg.MultiplayerUrl))
+                        endpoints.MultiplayerUrl = $"{endpoints.APIUrl}/signalr/multiplayer";
+
+                    if (string.IsNullOrWhiteSpace(cfg.MetadataUrl))
+                        endpoints.MetadataUrl = $"{endpoints.APIUrl}/signalr/metadata";
+
+                    if (string.IsNullOrWhiteSpace(cfg.BeatmapSubmissionServiceUrl))
+                        endpoints.BeatmapSubmissionServiceUrl = $"{endpoints.APIUrl}/beatmap-submission";
+                }
+
+                // Apply advanced overrides last (so they win over derived defaults :> )
+                applyOptionalUrlNoTrailingSlash(ref endpoints.BeatmapSubmissionServiceUrl, cfg.BeatmapSubmissionServiceUrl, nameof(cfg.BeatmapSubmissionServiceUrl));
+                applyUrl(ref endpoints.SpectatorUrl, cfg.SpectatorUrl, nameof(cfg.SpectatorUrl));
+                applyUrl(ref endpoints.MultiplayerUrl, cfg.MultiplayerUrl, nameof(cfg.MultiplayerUrl));
+                applyUrl(ref endpoints.MetadataUrl, cfg.MetadataUrl, nameof(cfg.MetadataUrl));
+
+                reason = $"{config_file} applied from storage";
+                return true;
+            }
+            catch (Exception ex)
+            {
+                Logger.Log($"Endpoint override failed: {ex}", LoggingTarget.Runtime, LogLevel.Error);
+                reason = "exception while applying override";
+                return false;
+            }
+        }
+
+        private static string? firstNonEmpty(params string?[] values)
+        {
+            for (int i = 0; i < values.Length; i++)
+            {
+                if (!string.IsNullOrWhiteSpace(values[i]))
+                    return values[i]!.Trim();
+            }
+
+            return null;
+        }
+
+        private static void applyString(ref string target, string? value)
+        {
+            if (!string.IsNullOrWhiteSpace(value))
+                target = value.Trim();
+        }
+
+        private static void applyUrlNoTrailingSlash(ref string target, string? value, string fieldName)
+        {
+            if (string.IsNullOrWhiteSpace(value))
+                return;
+
+            string v = value.Trim().TrimEnd('/');
+
+            if (!Uri.TryCreate(v, UriKind.Absolute, out _))
+                throw new InvalidDataException($"{fieldName} must be an absolute URL");
+
+            target = v;
+        }
+
+        private static void applyOptionalUrlNoTrailingSlash(ref string? target, string? value, string fieldName)
+        {
+            if (string.IsNullOrWhiteSpace(value))
+                return;
+
+            string v = value.Trim().TrimEnd('/');
+
+            if (!Uri.TryCreate(v, UriKind.Absolute, out _))
+                throw new InvalidDataException($"{fieldName} must be an absolute URL");
+
+            target = v;
+        }
+
+        private static void applyUrl(ref string target, string? value, string fieldName)
+        {
+            if (string.IsNullOrWhiteSpace(value))
+                return;
+
+            string v = value.Trim();
+
+            if (!Uri.TryCreate(v, UriKind.Absolute, out _))
+                throw new InvalidDataException($"{fieldName} must be an absolute URL");
+
+            target = v;
+        }
+    }
+}
diff --git a/osu.Game/Overlays/Settings/Sections/Online/PrivateServersSettings.cs b/osu.Game/Overlays/Settings/Sections/Online/PrivateServersSettings.cs
new file mode 100644
index 0000000000..ef3166a2c7
--- /dev/null
+++ b/osu.Game/Overlays/Settings/Sections/Online/PrivateServersSettings.cs
@@ -0,0 +1,236 @@
+using System;
+using System.IO;
+using System.Text.Json;
+using osu.Framework.Allocation;
+using osu.Framework.Graphics;
+using osu.Framework.Graphics.Containers;
+using osu.Framework.Logging;
+using osu.Framework.Localisation;
+using osu.Framework.Platform;
+using osu.Game.Graphics.UserInterfaceV2;
+using osu.Game.Overlays.Settings;
+
+namespace osu.Game.Overlays.Settings.Sections.Online
+{
+    public partial class PrivateServersSettings : SettingsSubsection
+    {
+        protected override LocalisableString Header => "Private servers";
+
+        private const string config_file = "endpoints.json";
+
+        private FormTextBox baseUrlTextBox = null!;
+        private FormTextBox apiUrlTextBox = null!;
+        private FormTextBox clientIdTextBox = null!;
+        private FormTextBox clientSecretTextBox = null!;
+
+        private SettingsButtonV2 saveButton = null!;
+        private SettingsButtonV2 resetButton = null!;
+
+        [Resolved]
+        private Storage storage { get; set; } = null!;
+
+        [BackgroundDependencyLoader]
+        private void load()
+        {
+            baseUrlTextBox = new FormTextBox
+            {
+                PlaceholderText = "https://yourserver.tld",
+            };
+
+            apiUrlTextBox = new FormTextBox
+            {
+                PlaceholderText = "(optional) defaults to base url",
+            };
+
+            clientIdTextBox = new FormTextBox
+            {
+                PlaceholderText = "(optional)",
+            };
+
+            clientSecretTextBox = new FormTextBox
+            {
+                PlaceholderText = "(optional)",
+            };
+
+            saveButton = new SettingsButtonV2
+            {
+                Text = "Save",
+                Action = save
+            };
+
+            resetButton = new SettingsButtonV2
+            {
+                Text = "Reset",
+                Action = reset
+            };
+
+            Children = new Drawable[]
+            {
+                new SettingsNote
+                {
+                    Text = "Configure a custom server for online features. Restart the game after saving."
+                },
+
+                new SettingsItemV2(baseUrlTextBox)
+                {
+                    Caption = "Server base url",
+                    TooltipText = "Website + API root. Must be an absolute HTTPS URL."
+                },
+
+                new SettingsItemV2(apiUrlTextBox)
+                {
+                    Caption = "API url (advanced)",
+                    TooltipText = "If your API root differs from the base url."
+                },
+
+                new SettingsItemV2(clientIdTextBox)
+                {
+                    Caption = "OAuth client id (advanced)",
+                    TooltipText = "Only required if your server expects OAuth like official."
+                },
+
+                new SettingsItemV2(clientSecretTextBox)
+                {
+                    Caption = "OAuth client secret (advanced)",
+                    TooltipText = "Only required if your server expects OAuth like official."
+                },
+
+                new FillFlowContainer
+                {
+                    AutoSizeAxes = Axes.Y,
+                    RelativeSizeAxes = Axes.X,
+                    Direction = FillDirection.Horizontal,
+                    Spacing = new osuTK.Vector2(10, 0),
+                    Children = new Drawable[]
+                    {
+                        saveButton,
+                        resetButton
+                    }
+                }
+            };
+
+            loadFromDiskIntoUI();
+        }
+
+        private sealed class EndpointConfigForDisk
+        {
+            public bool Enabled { get; set; } = true;
+
+            public string? BaseUrl { get; set; }
+
+            public string? APIUrl { get; set; }
+            public string? APIClientID { get; set; }
+            public string? APIClientSecret { get; set; }
+        }
+
+        private void loadFromDiskIntoUI()
+        {
+            try
+            {
+                if (!storage.Exists(config_file))
+                    return;
+
+                string fullPath = storage.GetFullPath(config_file);
+                if (!File.Exists(fullPath))
+                    return;
+
+                string json = File.ReadAllText(fullPath);
+
+                var options = new JsonSerializerOptions
+                {
+                    PropertyNameCaseInsensitive = true,
+                    ReadCommentHandling = JsonCommentHandling.Skip,
+                    AllowTrailingCommas = true
+                };
+
+                var cfg = JsonSerializer.Deserialize<EndpointConfigForDisk>(json, options);
+                if (cfg == null)
+                    return;
+
+                baseUrlTextBox.Text = cfg.BaseUrl ?? string.Empty;
+                apiUrlTextBox.Text = cfg.APIUrl ?? string.Empty;
+                clientIdTextBox.Text = cfg.APIClientID ?? string.Empty;
+                clientSecretTextBox.Text = cfg.APIClientSecret ?? string.Empty;
+            }
+            catch (Exception ex)
+            {
+                Logger.Log($"Failed reading {config_file}: {ex}", LoggingTarget.Runtime, LogLevel.Error);
+            }
+        }
+
+        private void save()
+        {
+            try
+            {
+                string baseUrl = (baseUrlTextBox.Text ?? string.Empty).Trim();
+                string apiUrl = (apiUrlTextBox.Text ?? string.Empty).Trim();
+                string clientId = (clientIdTextBox.Text ?? string.Empty).Trim();
+                string clientSecret = (clientSecretTextBox.Text ?? string.Empty).Trim();
+
+                if (string.IsNullOrWhiteSpace(baseUrl))
+                    throw new InvalidDataException("Base url is required.");
+
+                baseUrl = normaliseAbsoluteUrlNoTrailingSlash(baseUrl, "base url");
+
+                if (!string.IsNullOrWhiteSpace(apiUrl))
+                    apiUrl = normaliseAbsoluteUrlNoTrailingSlash(apiUrl, "api url");
+
+                var cfg = new EndpointConfigForDisk
+                {
+                    Enabled = true,
+                    BaseUrl = baseUrl,
+                    APIUrl = string.IsNullOrWhiteSpace(apiUrl) ? null : apiUrl,
+                    APIClientID = string.IsNullOrWhiteSpace(clientId) ? null : clientId,
+                    APIClientSecret = string.IsNullOrWhiteSpace(clientSecret) ? null : clientSecret
+                };
+
+                var options = new JsonSerializerOptions { WriteIndented = true };
+                string json = JsonSerializer.Serialize(cfg, options);
+
+                string fullPath = storage.GetFullPath(config_file);
+                File.WriteAllText(fullPath, json);
+
+                Logger.Log($"Wrote {config_file} to: {fullPath}", LoggingTarget.Runtime, LogLevel.Important);
+            }
+            catch (Exception ex)
+            {
+                Logger.Log($"Failed writing {config_file}: {ex}", LoggingTarget.Runtime, LogLevel.Error);
+            }
+        }
+
+        private void reset()
+        {
+            try
+            {
+                string fullPath = storage.GetFullPath(config_file);
+
+                if (File.Exists(fullPath))
+                    File.Delete(fullPath);
+
+                baseUrlTextBox.Text = string.Empty;
+                apiUrlTextBox.Text = string.Empty;
+                clientIdTextBox.Text = string.Empty;
+                clientSecretTextBox.Text = string.Empty;
+
+                Logger.Log($"{config_file} removed: {fullPath}", LoggingTarget.Runtime, LogLevel.Important);
+            }
+            catch (Exception ex)
+            {
+                Logger.Log($"Failed removing {config_file}: {ex}", LoggingTarget.Runtime, LogLevel.Error);
+            }
+        }
+
+        private static string normaliseAbsoluteUrlNoTrailingSlash(string value, string fieldName)
+        {
+            string v = value.Trim().TrimEnd('/');
+
+            if (!Uri.TryCreate(v, UriKind.Absolute, out var uri))
+                throw new InvalidDataException($"{fieldName} must be an absolute URL.");
+
+            if (!string.Equals(uri.Scheme, "https", StringComparison.OrdinalIgnoreCase))
+                throw new InvalidDataException($"{fieldName} must be HTTPS for iOS.");
+
+            return v;
+        }
+    }
+}
diff --git a/osu.Game/Overlays/Settings/SettingsSection.cs b/osu.Game/Overlays/Settings/SettingsSection.cs
index 5a57114deb..a73c55fe78 100644
--- a/osu.Game/Overlays/Settings/SettingsSection.cs
+++ b/osu.Game/Overlays/Settings/SettingsSection.cs
@@ -109,15 +109,21 @@ private void load(OverlayColourProvider colourProvider)
                                 Top = 24,
                                 Bottom = 40,
                             },
-                            Children = new Drawable[]
+                            Child = new FillFlowContainer
                             {
-                                new OsuSpriteText
+                                RelativeSizeAxes = Axes.X,
+                                AutoSizeAxes = Axes.Y,
+                                Direction = FillDirection.Vertical,
+                                Children = new Drawable[]
                                 {
-                                    Font = OsuFont.TorusAlternate.With(size: header_size),
-                                    Text = Header,
-                                    Margin = SettingsPanel.CONTENT_PADDING,
-                                },
-                                FlowContent
+                                    new OsuSpriteText
+                                    {
+                                        Font = OsuFont.TorusAlternate.With(size: header_size),
+                                        Text = Header,
+                                        Margin = SettingsPanel.CONTENT_PADDING,
+                                    },
+                                    FlowContent
+                                }
                             }
                         },
                         dim = new Box
-- 
2.50.1.windows.1

